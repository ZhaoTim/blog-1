#  拒绝 996 系列之自动化工具

对于大多数互联网公司来说，996 已经成为了常态，马云也说 996 是「修来的福报」。作为一个程序员，996 仿佛就是我们的宿命。但是以牺牲健康为代价的「福报」真的值得吗？「工作 996，生病 ICU」，更要命的是得了绝症还可能被公司开除。在 996 的大环境下，程序员如何才能完成「自我救赎」呢？

其实造成 996 的原因无非就两点：要么是干活的人效率太低，要么是活太多了根本干不完。下面列举几个具体场景：



效率低：

1. 代码的设计无法快速响应需求的变更。当一个新需求过来时，只能推倒重写。
2. 代码质量差，需要花很多时间去定位 Bug 并修复。
3. 大量的模板代码。

活太多：

1. 三个月的活必须一个月干完。
2. 需求不停地变更。
3. Bug 太多。本来开开心心下班了，结果又来了一堆 Bug。



无论是效率低还是活太多，理论上我们只要能完成得「又快又好」就可以不用加班了。但人不是机器，质量和速度很难二者兼得。因此，我们需要自动化工具来帮我们减轻负担。这篇文章会讨论如何通过自动化工具，来解决前后端集成的问题。



## 前后端分离带来的困扰

随着前后端分离，开发的门槛降低了，我们不再要求团队中的每个开发都是全栈工程师，这样更容易找到项目的合适人选。同时，团队也划分成了前端和后端两个团队。前端负责消费 API 并展示页面，后端负责提供 API。这两个团队可以并行开发互不影响，大大提升了效率。虽然前后端分离解决了很多问题，但同时也带来了新的困扰。

前后端成为两个独立团队之后，协作的问题便随之而来。通过什么来协作呢？契约。简单来说，就是预先定义好精准的接口，比如接口的 URL，包含哪些参数、返回值，每个值的类型，是否为空等等。定义好之后，前后端就按照契约进行开发。但是在实际场景中，却经常出现问题。

举个真实的例子。有一次，后端在重构时修改了一个字段名，同时也修改了契约测试，但是却忘了告诉前端。由于这个页面的使用频率不高，前端也工作在别的地方，因此那个页面挂了许久都没有人发现。这些隐藏 Bug 会给我们的应用带来隐患，同时也增加了开发的负担。

在实际开发过程中，保证人人都遵守契约是一个很困难的事情，因为人都可能会犯错。



## 大量的模板代码

即便团队中所有人都能严格遵循契约，但集成 API 仍旧是个苦力活。我需要定义请求的 URL、Method、参数、参数类型以及返回值类型等等。于是项目中就充斥着下面这样的模板代码：



 ```typescript
interface ICreateBookRequestData {
  bookId: string;
  category: string;
  date: string;
  createdBy: string;
}

interface ICreateBookReponseData {
  id: string;
  author: string;
  name: string;
  price: string;
  publishDate: string;
  publishVendor?: string;
}

export const createBook = createRequestAction<ICreateBookRequestData, ICreateBookReponseData>(
  "@@books/createBook",
  (data) => ({
    url: "/books/book",
    method: "PUT",
    data,
  }),
);
 ```



在多人协作时，为了减少冲突，我们按照业务场景，将请求相关的代码存储到了不同的文件。但是同时也造成了另一个问题，那就是重复定义和定义不一致的问题。在上面的代码中，我们定义了请求返回值的类型：`ICreateBookReponseData`。但在另一个文件中，不知道这个 interface 已经被定义过了，于是又重新定义了一遍。由于不同的人对 interface 的理解不一致，还可能造成了不一致的问题。



```typescript
interface IGetBookReponseData {
  id: string;
  author: string;
  name: string;
  price: string;
  publishDate: string; 
  publishVendor: string;  // publishVendor 在这里中是 required 属性 
}
```



## 通过自动化工具重新联结

为了解决上面的问题，我实现了一个自动化工具，将割裂的前端和后端重新连接起来。简单来说，就是通过 Swagger JSON 自动生成调用 API 所需的代码以及类型定义。

>  Swagger 是一个基于 OpenAPI 的规范， 它为 RESTful API 定义了一个与语言无关的标准接口，允许人和计算机发现和理解服务的功能，而无需通过访问源代码、文档或开发者工具。

有了这个工具之后，你只需要在命令行中执行一行命令 `npm run codegen` ，就能立刻生成项目中所有 API 相关的代码以及类型定义。这样就不用再写那些模板代码了，节省了很多时间。同时，由于所有代码都是通过 Swagger JSON 生成出来的，当接口发生变动时，我们不用再去询问后端修改了什么或者查看文档，只需要执行一行命令，就能够马上知道哪些接口发生了改变。因为所有代码都是自动生成的，重复定义的问题也就不存在了。如果业务场景比较简单，集成 API 就是一行代码的事：



```typescript
// getBooksUsingGET 方法由工具自动生成

const [books] = useTempData(getBooksUsingGET, { bookType }, [bookType]);

// 拿到 books 数据，渲染 UI
```



## 艰难的落地

当我把工具写好，想在项目中用起来时，却被 TL 一盆冷水泼下来。如何保证每个人生成出来的代码是一致的？如何进行多人协作？当后端进度落后于前端时，如何保证先有 Swagger 定义？TL 说我的这套方案在执行时会出现问题，不打算让我在项目上推行。

在项目上推一个新东西真的很困难，我早就已经习惯了。回想当初在项目上推动 TypeScript、RxJS、React Render Props...... 哪一次不是困难重重？哪一次没有花费巨大努力？本着不抛弃不放弃的精神，我把上面的问题一一整理出来，以解决 TL 的担心。

第一个问题，如何保证每个人生成出来的代码时一致的？这个问题很简单。每次运行命令，都从远程服务器上拿到 Swagger JSON，生成对应的代码，然后覆盖之前的文件即可。生成的文件不能手动修改，只能自动生成，否则你的修改就会被别人覆盖掉。同时跟 package-lock.json 一样，我们会对生成的代码进行排序，以减少生成文件的变化。这样就能够通过 Git Diff 准确的知道哪些地方发生了改变。

第二个问题，如何进行多人协作？如果后端修改了一个字段名，可能会造成前端所有使用这个字段的地方都编译错误。这时如果大家都去修改编译问题，虽然不一定会造成冲突，但是还是会造成时间上的浪费。这在没有自动化工具之前同样会发生。好在这个问题发生的频率并不高，我们可以和项目成员进行约定：如果有人正好在做这个功能，那么就由他来修改，否则就让 TL 去协调安排。

最后一个问题，如何保证先有 Swagger 定义？由于前后端是两个独立的团队，所以进度也常常不同。后端可能无法先于前端实现好 API，甚至无法和前端同时去做一个功能。而这套方案依赖于 Swagger 定义，必须先有 Swagger 定义，才能生成代码。如果前端要先于后端完成某个功能，最好先和后端商定好 API Schema 再进行开发。定义好 API Schema 之后，随之更新 Swagger 文档就行了。



通过激烈的讨论，TL 最终还是同意我在项目上推动这个工具了。



## 成果

结果就是，前端终于不用再写这些无聊的代码啦！集成 API 变成了一件很容易的事情。而且我们再也不用担心后端悄悄改接口了！当后端发生变动时，前端也能及时得知并作出修改。到目前为止，这个自动化工具已经为我们项目生成了上万行代码。不仅提升了大家的效率，同时也减少了因为不遵循契约带来的隐藏 Bug。



## 最后

如果能够通过自动化工具提升效率，既为公司节省了成本，又减轻了自己的工作负担。互利共赢，为啥非要 996 呢？早早下班吃饭不好吗？最后，我想说不加班的程序员才是好程序员。















----

遇到问题，可以自动化。做一个不用 996 的程序员。

如何提升自己和同事的效率，减少模板代码对于效率和精神的损耗。

算算这笔时间账。

反向支撑后端重构、后端说我们要重构、改个字段，API mock 数据自动更新就行，非常方便。

一个 API 可能要半个小时去写 interface、集成API、mock 数据、测试。成百上千的 API，为每个人节省了多少时间？





从去年开始，大家就一直在讨论 996 这个话题。马云爸爸甚至说 996 是「修福报」。但是作为一个程序员，我是打心眼里看不起那些要 996 的人。996 反映了很多问题，一种是公司的问题，一种是自己的问题。本来要干半年的活，需要三个月干完。除了加班还有别的方式吗？还有一种是效率问题，一个 bug 可能别人几分钟就搞定了，而你却要花上好几个小时。



在华为工作时，加班到 9 点，改了一行代码的例子。

AI 智能的时代，机器写代码？在还没那么智能的时代，我们能想点别的方法减轻这方面的问题吗？



- 效率太低
  - 沟通成本



我们要向 996 Say No! 作为一个前端开发，能不能从程序这里想点办法？



同样一个问题，有的人两分钟就解决了，有的人却要花上两小时。

解决方案：

- 快速响应需求的变更
- 减少 Bug 的出现
- 出现 Bug 之后能够快速定位和修复
- 组件复用（50%的时间都是在写组件）



契约就好比法律，只有大家都遵守并执行才会产生效力，否则就是一张废纸。就跟我们的劳动法一样，虽然规定了工作 8 小时，但是很多公司还是强制 996。









前后端完全割裂开来，前后端各自成为一个黑盒。这样虽然职责分离，前后端可以并行开发，但是也带来了新的问题。需要通过一种方式，将前后端重新联系起来。



在没有 codegen 之前是什么样的？

- 大量模板代码

- 可能重复定义 interface，造成混乱
- 比较难 debug







- 节省很大的前端工作量
- 解决前后端定义不一致的问题
- 解决前端重复定义 API Request / API Response 等模型的问题
- 替代契约测试的功能，当 API Schema 发生变化时，前端立刻得知结果，即 compile 失败。无需手动更新 API Schema，一个命令自动更新。
- 当 swagger 中有相同的 enum 定义时，只生成一个 enum，还是生成带前缀的不同的 enum？



如果不进行排序，可能会导致每次出来的代码的顺序是混乱的，会产生无用的 Git Diff。



---

- 跟 package.json 一样，可以保证每个人生成出来的东西是一致的。这个东西不要本地修改，否则修改会被覆盖。对生成的方法进行排序，对 Git 友好。

- 多人协作的问题？如果都在改，可能会出现 conflict？出现 Conflict 的情况有哪些？
  - 后端增加了一个字段 - 不会出现问题
  - 后端删除了一个字段 - 可能会出现问题
  - 后端修改了一个字段的名字 - 可能会造成前端所有使用这个字段的地方都出现问题，无法通过编译。这个时候由谁来修改？如果那个人恰好工作在这张卡上，由他进行修改。后端重构导致以前的接口发生变化了，这时候所有人都没有工作在这个卡上，那么又由谁来修改的问题？（协作问题，这个问题其实以前也会有，现在反而更好的解决）。
  - 如果后端改了一个字段，不期望前端进行修改，那怎么办？这种情况已经导致前端功能出现问题了，难道不应该马上修复吗？卡的拆分的问题，后端先修改了，前端下个迭代才做这个卡的问题。

- 强依赖于后端的 API Schema，必须先定义好 Schema 才能开发前端。

- 在前后端进行开发之前，本来就要一起先把 API Schema 定义好。这样前端和后端一起定义，这样增强了沟通。

- 前后端进度不一致的问题，前端进度很快，后端进度很慢，导致后端无法先于前端实现好 API，甚至无法同时开始做一张卡。这时候面临的问题，就是你应该找谁一起定义 API Schema？后端都忙于自己的工作，无法抽出时间和你定义一些「超前进度」的 API Schema，这时候前端可以自己定义好 Schema，但是不实现任何内容。如果后端之后做卡时发现要修改 API Schema，配合自动生成工具和 TypeScript，前端也能更好的应对。

- 使用 Dev 环境还是 QA 环境来生成 API 的问题？Dev 代表这最新的 API（我们期望的结果，但是可能处于不稳定的状态），QA 环境（相对稳定，可是无法拿到最新的 API）。

- 有一些 require 的字段后端没有加 require，所以导致自动生成的东西不可信的问题。





当没有后端在做这个功能时，找谁一起定义 API Schema 就成为了一个问题。如果后端都忙于自己的工作，无法抽出时间和你定义一些「超前进度」的 API Schema，这时候前端可以先生成 Swagger 定义，但是不实现任何内容。如果后端之后要修改 API Schema，通过自动生成工具，前端也能很好应对。



在推代码之前会先检查编译是否正确，编译正确才能将代码推到远端。

