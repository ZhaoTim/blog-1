# RBAC 权限控制在前端的应用



RBAC（Role-Based Access Control）即基于角色的访问控制。RBAC 认为授权其实就是 who, what, how 三者之间的关系，即 who 对 what 进行 how 操作。简单来说就是某个角色 (who) 对某个资源 (what) 拥有怎样的 (how) 权限。



对于前端来说，按照控制粒度的不同，可以分为页面级和组件级两种权限控制：

1. 页面级别的权限控制粒度较粗，只能控制到页面层。对于不同角色来说：要么能看到这个页面，要么连页面都进不去。本质上就是对路由进行权限控制。
2. 组件级别的权限控制粒度更细，可以精确地控制每个 UI 元素显示是否。对于不同角色来说：他们都能看到同一个页面，但不同的是有的角色可以看到三个按钮，有的角色只能看到其中两个。



## 最初的权限控制方案

如果要对一个按钮增加权限控制通常是这样的，在这个按钮外包裹一个组件，这个组件会根据 `permittedRoles` 属性去决定是否要渲染其子组件。

```jsx
<AccessControl permittedRoles={["RoleA", "RoleB", "RoleC"]}>
  <Button />
</AccessControl>
```



`permittedRoles` 的逻辑是只要其中任意一个角色有权限，那么就渲染这个组件：



```typescript
import React, { ReactNode, useContext } from "react";
import { AuthorizationContext } from "./AuthorizationContext";
import { intersection, isEmpty } from "lodash";

export enum Role {
  A = "ROLE_A",
  B = "ROLE_B",
}

interface IAccessGuardProps {
  permittedRoles: Role[];
  children: ReactNode;
}

export const AccessControl = ({ permittedRoles, children }: IAccessGuardProps) => {
  const { currentUserRoles } = useContext(AuthorizationContext);
  return isEmpty(intersection(permittedRoles, currentUserRoles)) ? null : children;
};
```



权限控制：

oneOf A, B, C

allOf A,B,C



这样带来的问题是：

1. 每个需要加权限的地方都需要配置 `permittedRoles`。逻辑分散在项目的各个角落，难以维护。
2. 测试困难。需要去测每个组件的渲染逻辑。比如是否根据正确的 `permittedRoles` 渲染了正确的 UI。如果没有写测试，非常容易出错。
3. 前后端的权限控制可能不一致。



如果是权限 + 状态的情况。



有的时候一个元素的显示与否，不仅和权限相关，也和数据状态相关。



改进：

将权限控制配置到一个文件中，可以进行统一管理。通过简单地 snapshot 测试就能够覆盖业务场景。





## BFF

由 BFF 返回一个 boolean 值，去控制某个 Button，解决的问题：

前端不用关心权限和状态，只需要通过一个 boolean  值，就能够确定 button 的显示与否。如果权限或者状态发生改变，只需要修改相应后端逻辑，无需重新部署前端。



缺点：

1. 控制属性可能无限扩张。如果一个页面有非常多需要控制的元素，接口会无限膨胀。就可能是这样的情况：

   ```json
   {
     "canViewProfile": true,
     "canEditProfile": false,
     "canDeleteProfile": false,
     "canViewHistory": true,
     "canEditHistory": false,
     "canDeleteHistory": false,
     "canCreateReport": false,
     "canViewReport": false,
     "canDeleteReport": false
   }
   ```

2. 因为需求的变化，前端某个元素发生改变，字段也可能需要重新命名。比如原来这个元素叫 History，现在扩展为 SubjectAndHistory，对应的控制这个元素的属性都需要修改。否则就会造成不一致。





## 通过后端接口自动配置权限

RBAC 控制的最小单元就是接口。让接口的权限和组件的显示与否一一对应。不会存在和后端不一致的情况。



优点：

1. 无需增加任何额外字段，只需要通过是否能够使用某个接口，就能判定某个元素是否显示。解决了接口无限膨胀的问题。
2. 减少前后端沟通成本。比如增加或减少一个用于权限控制的接口字段。



最终决定元素的显示与否，可能是权限 + 数据状态。



权限 + 数据状态：

1 对 多：后端 

   1. 无限膨胀

      

表达式：避免服务重启。

后端动态 Render ：解决了无限膨胀的问题、更灵活。但是页面元素相对固定，如果要增加或者修改都很困难。



1 对 1： 前端

1. 状态单独判断。（修改、部署困难）
2. 需求变更的情况。









































- 对路由的权限控制

- 局部 UI 组件的显示与否。如果用户没有某个权限，点击某个 button 时会抛出 error message，是否考虑 hide button 或者提示用户？

  

