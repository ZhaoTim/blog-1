# RBAC 权限控制的实现

RBAC（Role-Based Access Control）即基于角色的访问控制。RBAC 认为授权其实就是 who, what, how 三者之间的关系，即 who 对 what 进行 how 操作。简单来说就是某个角色 (who) 对某个资源 (what) 拥有怎样的 (how) 权限。



对于前端来说，按照控制粒度的不同，可以分为页面级和组件级两种权限控制：

1. 页面级别的权限控制粒度较粗，只能控制到页面层。对于不同角色来说：要么能看到页面，要么连页面都进不去。本质上就是对路由进行权限控制。
2. 组件级别的权限控制粒度更细，可以精确地控制每个 UI 元素显示是否。对于不同角色来说：他们都能看到同一个页面，但不同的角色看到的 UI 元素不同。比如有的角色可以看到三个按钮，有的角色只能看到其中两个。



## 页面的权限控制

前端控制

后端控制

前端的路由大部分都是通过配置。





## 组件的权限控制

每一个需要权限控制的组件，都需要增加相应逻辑。因此为了方便使用，可以通过公用组件来进行权限控制。如下所示：



```typescript
import React, { ReactNode, useContext } from "react";
import { AuthorizationContext } from "./AuthorizationContext";
import { intersection, isEmpty, isEqual } from "lodash";

export enum Role {
  A = "ROLE_A",
  B = "ROLE_B",
}

interface IAccessGuardProps {
  permittedRoles: Role[];
  children: ReactNode;
}

export const OneOfAccessControl = ({ permittedRoles, children }: IAccessGuardProps) => {
  const { currentUserRoles } = useContext(AuthorizationContext);
  return isEmpty(intersection(permittedRoles, currentUserRoles)) ? null : children;
};
```



我们抽象了一个组件  `OneOfAccessControl` ，它接收两个属性： `permittedRoles` 和 `children`。`permittedRoles` 表示允许哪些角色看到 `children`。我们从 `context` 中拿到当前用户所拥有的角色，并和 `permittedRoles` 取交集。只要其中任意一个角色被允许就渲染其子组件，否则就返回空。同理，如果期望传入的所有角色都被允许才渲染子组件，我们还可以抽象另一个组件 `AllOfAccessControl` ：



```typescript
export const AllOfAccessControl = ({ permittedRoles, children }: IAccessGuardProps) => {
  const { currentUserRoles } = useContext(AuthorizationContext);
  return isEqual(intersection(permittedRoles, currentUserRoles), permittedRoles) ? children : null;
};
```



因此，如果要对一个按钮增加权限控制，只需要在它外面包裹一个组件，然后配置允许访问的角色即可。如下所示：



```jsx
<OneOfAccessControl permittedRoles={["RoleA", "RoleB", "RoleC"]}>
  <Button />
</OneOfAccessControl>
```



这种方式虽然为我们省去了不少工作，但是在使用这个方案的过程中，问题也逐渐暴露出来：

1. 配置 `permittedRoles` 可能出错，且逻辑分散在项目的各个角落，难以维护。
2. 增加单元测试成本。为了每个 UI 组件都正确设置了访问权限，我们需要为它们增加单元测试。但是测试组件是否根据 `permittedRoles` 渲染了正确的 UI，是一笔很大的开销。
3. 前后端权限控制不一致的问题。某个角色能看到哪些 UI 元素是由前端控制的，而他能够调用哪些接口是由后端决定的。有时候由于沟通协作的问题，可能会导致某个角色能看到某个 UI 元素，但是无法调用对应接口的问题。





如果是权限 + 状态的情况。



有的时候一个元素的显示与否，不仅和权限相关，也和数据状态相关。



改进：

将权限控制配置到一个文件中，可以进行统一管理。通过简单地 snapshot 测试就能够覆盖业务场景。









### BFF

由 BFF 返回一个 boolean 值，去控制某个 Button，解决的问题：

前端不用关心权限和状态，只需要通过一个 boolean  值，就能够确定 button 的显示与否。如果权限或者状态发生改变，只需要修改相应后端逻辑，无需重新部署前端。



缺点：

1. 控制属性可能无限扩张。如果一个页面有非常多需要控制的元素，接口会无限膨胀。就可能是这样的情况：

   ```json
   {
     "canViewProfile": true,
     "canEditProfile": false,
     "canDeleteProfile": false,
     "canViewHistory": true,
     "canEditHistory": false,
     "canDeleteHistory": false,
     "canCreateReport": false,
     "canViewReport": false,
     "canDeleteReport": false
   }
   ```

2. 因为需求的变化，前端某个元素发生改变，字段也可能需要重新命名。比如原来这个元素叫 History，现在扩展为 SubjectAndHistory，对应的控制这个元素的属性都需要修改。否则就会造成不一致。





### 通过后端接口自动配置权限

RBAC 控制的最小单元就是接口。让接口的权限和组件的显示与否一一对应。不会存在和后端不一致的情况。



优点：

1. 无需增加任何额外字段，只需要通过是否能够使用某个接口，就能判定某个元素是否显示。解决了接口无限膨胀的问题。
2. 减少前后端沟通成本。比如增加或减少一个用于权限控制的接口字段。



最终决定元素的显示与否，可能是权限 + 数据状态。



权限 + 数据状态：

1 对 多：后端 

   1. 无限膨胀

      

表达式：避免服务重启。

后端动态 Render ：解决了无限膨胀的问题、更灵活。但是页面元素相对固定，如果要增加或者修改都很困难。



1 对 1： 前端

1. 状态单独判断。（修改、部署困难）
2. 需求变更的情况。











## Dynamic Content

和组件化开发的思路是一样的。我们可以进一步抽象，将页面元素划分为可配置的 block，不同的 block 包含不同的类型或对应的配置值，如 Section, Image, Paragraph 等，当然每种类型的 block，是需要前端开发完备的，支持对应配置项。然后我们便可通过 JSON 来描述和存储页面，比如

```jsx
const Page = (
  <>
    <Section>
      <Paragraph content="xxxxxx"/>
      <Image src="http://xxx">
    </Section>
    <Section>
      <Paragraph content="content">
    </Section>
  </>
)
```

可以描述为

```json
[
  {
    "type": "Section",
    "children": [
      {
        "type":"Paragraph",
        "content": "xxxxxx"
      },
      {
        "type":"Image",
        "src": "http://xxx"
      }
    ]
  },
  {
    "type": "Section",
    "children": [
      {
        "type":"Paragraph",
        "content": "content"
      }
    ]
  }
]
```

虽然看上去复杂了不少，但由于 JSON 无关语言，易于传输与存储的特性。我们可以这份 JSON 可存放到服务端，前端获取这一 JSON 配置，渲染最终页面。在一些特殊需求中（RBAC，定向广告），服务进行适当删减，使得显示内容得以动态。

参考: https://www.contentful.com/



## Dynamic Form

同样的，更复杂的表单，也是一样的思路，只是对于 Form，有一个额外的功能点，即表单可能随着用户的输入而变化。

既然是表单，最终是需要提交的，所以一般而言我们会为 Dynamic Form 定义两个部分。

一个是提交数据的声明结构，这个采用 JSON Schema 即可。如提交数据为

```json
{
  "name": "xxx",
  "age": 1,
  "gender": "male"
}
```

我们可以用如下声明表示

```json
{
  "type": "object",
  "properties": {
    "name": {
      "type": "string"，
      "pattern": "[\w]{2,}"，
      "x-error": "名字长度不够"
    },
    "gender": {
      "type": "string",
      "enum": ["male", "female"],
      "x-enum-labels": ["男"，"女"]
    }，
    "age": {
      "type": "number",
      "mininum": 20，
      "x-error": "年龄太小"
    }
  }
}
```

然后前端根据不同的类型，渲染对应的组件，

* `type: "string"` 我们可以用  `TextInput` 渲染，`type: "number"` 我们可以用 `NumberInput` 渲染，我们可以 JSON Schema 的 validations 属性来进行输入检查， 由于 JSON Schema 毕竟是设计来描述数据结构的，对错误的 inline error，我们可以扩展 `error` 来描述。
* `type: "number"` 我们可以用 `NumberInput` 渲染，
* `enum` 我们可以用  `SelectInput` 渲染。同样的，对于选项文本的描述需要我们自己扩展，如上面例子中的 `x-enum-labels` ，



对于响应用户输入变化，JSON Shema 有对应的方案。https://json-schema.org/understanding-json-schema/reference/conditionals.html，如下，男女法定婚龄不同，JSON Schema 可定义为，前端组件做出对应的处理即可。

```json
{
  "type": "object",
  "properties": {
    "name": {
      "type": "string"，
      "pattern": "[\w]{2,}"，
      "x-error": "名字长度不够"
    },
    "gender": {
      "type": "string",
      "enum": ["male", "female"],
      "x-enum-labels": ["男"，"女"]
    }，
    "age": {
      "type": "number"
    }
  },
  "if": {
    "properties": { "gender": { "const": "male" } }
  },
  "then": {
    "properties": { "age": { "mininum": 22 } }
  },
  "else": {
    "properties": { "age": { "mininum": 20 } }
  }
}
```



可是这个方案确实不够强大，对应。

这里还有另一种方式，借鉴自一个地图引擎，https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions，对于复杂场景，来定义 validation `x-validation` 和 condition `x-when`，还可以支持复杂情况

```json
[expression_name, argument_0, argument_1, ...]

["one", ...]
["all", ...] 
["match", pattern, msg]
["get", path]
["case", defaultResult, case1, result1, ...]
[">", target, v]
[">=", target, v]
["==", target, v]
["<", target, v]
["<=", target, v]
```



```json
{
  "type": "object",
  "properties": {
    "name": {
      "type": "string"，
// if (len(field_value) == 0) return "不能为空"
// if (!(/[\w]{2,}/.text(field_value))) return "名字长度不够"
// return ""      
      "x-validate": [
         "case",
         "",
         ["==", ["len"，"$value"], 0], "不能为空",
         ["not", ["match", "$value", [\w]{2,}"]], "名字长度不够",
      ] 
    },
    "gender": {
      "type": "string",
      "enum": ["male", "female"],
      "x-enum-labels": ["男"，"女"]
    }，
    "age": {
      "type": "number"，
// get(values, "gender") && <Field/>      
      "x-when": [
      	"get", "gender",
      ],
// if (get(values, "gender") == "male" && field_value <= 22) return "年龄太小"
// if (get(values, "gender") == "female" && field_value <= 20) return "名字长度不够"
// return "" 
      "x-validate": [
        "case",
        "",
        ["all",
           ["==", ["get", "$values", "gender"], "male"],
           ["<=", 22]
        ], "年龄太小"],
        ["all",
           ["==", ["get", "$values", "gender"], "female"],
           ["<=", 20]
        ], "年龄太小"],
      ]
    }
  }
}
```

至于如何去解析并运算表达式，这算是函数式编程的别样用法。



























权限控制：

oneOf A, B, C

allOf A,B,C



- 对路由的权限控制

- 局部 UI 组件的显示与否。如果用户没有某个权限，点击某个 button 时会抛出 error message，是否考虑 hide button 或者提示用户？

  

